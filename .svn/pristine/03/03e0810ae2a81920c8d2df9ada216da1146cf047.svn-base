-- | Este módulo define funções comuns da Tarefa 2 do trabalho prático.
module Tarefa2_2018li1g027 where

import Tarefa1_2018li1g027
import LI11819
import Data.List
import TestesT2

data JAtual = JAtual
  { player :: Jogador
  , playerPos :: PosicaoGrelha
  , playerDir :: Direcao
  , playerIndex :: Int
  , playerLives :: Int
  , othersPlayersPos :: [PosicaoGrelha]
  , mapaAtual :: Mapa
  , posChoque :: [PosicaoGrelha] -- posicoes afetadas pelo choque
  }

-- | Testes unitários da Tarefa 2.
--
-- Cada teste é um triplo (/identificador do 'Jogador'/,/'Jogada' a efetuar/,/'Estado' anterior/).
testesT2 :: [(Int,Jogada,Estado)]
testesT2 = teste 
-- * Funções principais da Tarefa 2.

ticks :: Ticks
ticks = 5

posGrelhaParaPos :: PosicaoGrelha -> Direcao -> [Posicao]
posGrelhaParaPos (li,co) dir | dir == C || dir == B = [(li,co), (li, succ co)]
                             | otherwise = [(li,co), (succ li, co)]

nextMovePos :: [Posicao] -> Direcao -> [Posicao]
nextMovePos l dir | dir == C || dir == E = map (somaVetores $ direcaoParaVetor dir) l
                  | otherwise            = map (somaVetores $ (\(x,y) -> (2*x,2*y)) $ direcaoParaVetor dir) l
                  
isEmpty :: Mapa -> [Posicao] -> [Bool]
isEmpty m pos = map (f m) pos
  where
    f :: Mapa -> Posicao -> Bool
    f mapa (li, co) = Vazia == (flip (!!) co $ head . drop li $ mapa)

canMove :: Mapa -> PosicaoGrelha -> Direcao -> Bool
canMove m pos dir = all id listaBool 
  where
    posicoesIniciais = posGrelhaParaPos pos dir
    posicoesFinais = nextMovePos posicoesIniciais dir
    listaBool = isEmpty m posicoesFinais

movimenta :: Direcao -> Mapa -> Jogador -> [PosicaoGrelha] -> Jogador
movimenta dir m (Jogador pos dirj v l c) allPlayerPos | dir /= dirj = (Jogador pos dir v l c)
                                                      | otherwise = if (canMove m pos dirj) && not (elem newP allPlayerPos)
                                                                    then (Jogador newP dir v l c)
                                                                    else (Jogador pos dir v l c)
  where
    newP = somaVetores pos $ direcaoParaVetor dir 

--recebe o estado e implementa o novo estado do jogador
replacePlayerEstado :: Estado -> Jogador -> Int -> Estado
replacePlayerEstado e@Estado{jogadoresEstado=playersEstado} player indice = let newPlayersEstado = replace indice player playersEstado
                                                                            in e{jogadoresEstado = newPlayersEstado}

replaceDirEstado :: Estado -> Jogador -> Int -> Direcao -> Estado
replaceDirEstado e@Estado{jogadoresEstado=playerEstado} (Jogador p d v l c) indice dir = let newDirPlayer = (Jogador p dir v l c)
                                                                                             newPlayersEstado = replace indice newDirPlayer playerEstado
                                                                                          in e{jogadoresEstado = newPlayersEstado}
replace :: Int -> a -> [a] -> [a]
replace _ _ [] = []
replace n newVal (x:xs) | n == 0 = newVal:xs
                        | otherwise = x:replace (n-1) newVal xs

verificaMunicao :: Arma -> Jogador -> Bool
verificaMunicao weapon player | weapon == Canhao || weapon == Laser = lasersJogador player > 0
                              | otherwise = choquesJogador player > 0

removeMunicao :: Arma -> Jogador -> Jogador
removeMunicao Choque j@Jogador{choquesJogador=x} = let newChoquesJ = pred x
                                                    in j{choquesJogador=newChoquesJ}
removeMunicao _ j@Jogador{lasersJogador=y} = let newLaserJ = pred y
                                              in j{lasersJogador=newLaserJ}


addDisparo :: Arma -> Estado -> Int -> PosicaoGrelha -> Direcao -> Estado
addDisparo Canhao e@Estado{disparosEstado=disp} pIndice pPos pDir = let shotPos = somaVetores pPos $ direcaoParaVetor pDir
                                                                        newlistaDisparos = (DisparoCanhao pIndice shotPos pDir) : disp 
                                                                     in e{disparosEstado = newlistaDisparos}
addDisparo Laser e@Estado{disparosEstado=disp} pIndice pPos pDir  = let shotPos = somaVetores pPos $ direcaoParaVetor pDir
                                                                        newlistaDisparos = (DisparoLaser pIndice shotPos pDir) : disp
                                                                     in e{disparosEstado = newlistaDisparos}
addDisparo Choque e@Estado{disparosEstado=disp} pIndice _ _       = let newlistaDisparos = (DisparoChoque pIndice ticks) : disp
                                                                     in e{disparosEstado = newlistaDisparos}

--Posicao dos jogadores que emitiram choques
posicaoJogadorChoque :: [Jogador] -> [Int] -> [PosicaoGrelha]
posicaoJogadorChoque player indices = let jogadoresChoque = map ((!!) player) indices
                                       in map posicaoJogador jogadoresChoque

indiceDisparoChoque :: [Disparo] -> [Int]
indiceDisparoChoque disparos = let choques = filter (\e -> case e of {DisparoChoque{} -> True; _ -> False}) disparos
                               in map jogadorDisparo choques  

--Posicoes que foram afetadas pelos choques
posAfetadasPorChoques :: PosicaoGrelha -> Mapa -> [PosicaoGrelha]
posAfetadasPorChoques (li,co) mapa = [(l,c) | l <- [linhaI..linhaF], c <- [colunaI..colunaF]]
  where
    linhaI  = if (li - 3) < 0 then 0 else li -3
    linhaF  = if (li + 3) < (length mapa) - 1 then li +3 else pred $ length mapa
    colunaI = if (co - 3) < 0 then 0 else co -3
    colunaF = if (co + 3) < (length $ head mapa) -1 then co +3 else pred $ length $ head mapa

jogar :: Int -- ^ O identificador do 'Jogador' que efetua a jogada.
       -> Jogada -- ^ A 'Jogada' a efetuar.
       -> Estado -- ^ O 'Estado' anterior.
       -> Either Estado JAtual -- ^ O 'Estado' resultante após o jogador efetuar a jogada.
jogar ind jog est = if ((vidasJogador. flip (!!) ind . jogadoresEstado) est <= 0)
                     then Left est
                     else Right $ toJAtual ind jog est

toJAtual :: Int -> Jogada -> Estado -> JAtual
toJAtual ind jog est = JAtual player pPos pDir ind pVidas allPlayerPos mapa afectedPos
  where
    (mapa, jogs, disps, player)  = (mapaEstado est, jogadoresEstado est, disparosEstado est, flip (!!) ind . jogadoresEstado $ est)
    (pPos,pDir,pVidas)           = (posicaoJogador player, direcaoJogador player, vidasJogador player)
    allPlayerPos                 = filter (/= pPos) $ map posicaoJogador jogs
    choquePosList                = posicaoJogadorChoque jogs $ indiceDisparoChoque disps --posicao dos jogadores que emitiram choque
    afectedPos                   = nub . concat $ map (flip posAfetadasPorChoques mapa) choquePosList --todas as posições afetadas por choque num mapa

executaJogada :: Jogada -> Estado -> JAtual -> Estado
executaJogada (Movimenta dir) est j = if elem (playerPos j) (posChoque j)
                                         then if (dir == playerDir j)
                                                 then est
                                                 else replaceDirEstado est (player j) (playerIndex j) dir
                                         else replacePlayerEstado est (movimenta dir (mapaAtual j) (player j) (othersPlayersPos j)) (playerIndex j)
executaJogada (Dispara arma) est j 
  | arma == Canhao || arma == Laser = let newPlayerEst = replacePlayerEstado est (removeMunicao arma (player j)) (playerIndex j)
                                          estadoAfterShot = addDisparo arma newPlayerEst (playerIndex j) (playerPos j) (playerDir j)
                                      in if verificaMunicao arma (player j)
                                         then estadoAfterShot
                                         else est
  | arma == Choque = let newPlayerEst = replacePlayerEstado est (removeMunicao arma (player j)) (playerIndex j)
                     in  addDisparo arma newPlayerEst (playerIndex j) (playerPos j) (playerDir j)

-- | Efetua uma jogada.
jogada :: Int -- ^ O identificador do 'Jogador' que efetua a jogada.
       -> Jogada -- ^ A 'Jogada' a efetuar.
       -> Estado -- ^ O 'Estado' anterior.
       -> Estado -- ^ O 'Estado' resultante após o jogador efetuar a jogada.
jogada ind jog est = either id (executaJogada jog est) $ jogar ind jog est