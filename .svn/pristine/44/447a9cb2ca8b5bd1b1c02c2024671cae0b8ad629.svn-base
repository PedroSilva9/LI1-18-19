-- | Este módulo define funções comuns da Tarefa 4 do trabalho prático.
module Tarefa4_2018li1g000 where

import LI11819
import TestesT3

-- * Testes
-- | Testes unitários da Tarefa 4.
--
-- Cada teste é um 'Estado'.
testesT4 :: [Estado]
testesT4 = []

-- * Funções principais da Tarefa 4.

-- | Avança o 'Estado' do jogo um 'Tick' de tempo.
--
-- __NB:__ Apenas os 'Disparo's afetam o 'Estado' do jogo com o passar do tempo.
--
-- __NB:__ Deve chamar as funções 'tickChoques', 'tickCanhoes' e 'tickLasers' pela ordem definida.
tick :: Estado -- ^ O 'Estado' anterior.
     -> Estado -- ^ O 'Estado' após um 'Tick'.
tick = tickChoques . tickCanhoes . tickLasers

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos tiros de 'Laser' disparados.
tickLasers :: Estado -> Estado
tickLasers e = undefined 
  where
    allLasers = filter (\e -> case e of {DisparoLaser{} -> True; _ -> False}) $ disparosEstado e 
    tuploPosDir = zip (map posicaoDisparo allLasers) (map direcaoDisparo allLasers)

--para cada disparo recebe a lista de pos e a dir e recebe a posicao dos indestrutiveis e retorna o caminho entre a posicao de disparo e a peca indestrutivel mais proxima.
allPosPath :: ([Posicao],Direcao) -> [Posicao] -> [Posicao] 
allPosPath ((x:xs:t),C) posInd = [(l,snd x) | l <- [maxRow .. fst x]] ++ [(l,snd xs) | l <- [maxRow .. fst xs]] 
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x) posInd, filter (\(a,b) -> b == snd xs) posInd)
    maxRow = max (maximum $ map fst sameColumnFst) (maximum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),D) posInd = [(fst x,c) | c <- [snd x .. minColumn]] ++ [(fst xs,c) | c <- [snd xs .. minColumn]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x) posInd, filter (\(a,b) -> a == fst xs) posInd)
    minColumn = min (minimum $ map snd sameRowFst) (minimum $ map snd sameRowSnd)
allPosPath ((x:xs:t),B) posInd = [(l,snd x) | l <- [fst x .. minRow]] ++ [(l,snd xs) | l <- [fst xs .. minRow]]
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x) posInd, filter (\(a,b) -> b == snd xs) posInd)
    minRow = min (minimum $ map fst sameColumnFst) (minimum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),E) posInd = [(fst x,c) | c <- [maxColumn .. fst x]] ++ [(fst xs,c) | c <- [maxColumn .. fst xs]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x) posInd, filter (\(a,b) -> a == fst xs) posInd)
    maxColumn = max (maximum $ map snd sameRowFst) (maximum $ map snd sameRowSnd)

shotAsTwoBlocks :: PosicaoGrelha -> Direcao -> ([Posicao], Direcao)
shotAsTwoBlocks (li,co) C = ([(li,co), (li,succ co)], C)
shotAsTwoBlocks (li,co) B = ([(succ li, co), (succ li, succ co)], B)
shotAsTwoBlocks (li,co) D = ([(li, succ co), (succ li, succ co)], D)
shotAsTwoBlocks (li,co) E = ([(li,co), (succ li,co)], E)

groupN :: [a] -> Int -> [[a]]
groupN [] _ = []
groupN l n = take n l : groupN (drop n l) n

posIndestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posIndestrutivel [] [] = []
posIndestrutivel (x:xs) (y:ys) = aux x y ++ posIndestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Indestrutivel) then y : aux xs ys else aux xs ys

posDestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posDestrutivel [] [] = []
posDestrutivel (x:xs) (y:ys) = aux x y ++ posDestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Destrutivel) then y : aux xs ys else aux xs ys

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos das balas de 'Canhao' disparadas.
tickCanhoes :: Estado -> Estado
tickCanhoes = undefined

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos campos de 'Choque' disparados.
tickChoques :: Estado -> Estado
tickChoques = undefined
