-- | Este módulo define funções comuns da Tarefa 6 do trabalho prático.
module Tarefa6_2018li1g027 where

import LI11819
import Tarefa2_2018li1g027
import Tarefa4_2018li1g027
import Control.Monad
import Data.Maybe
import Data.List
-- PRIORIDADES
-- 1 - Verificar se esta numa zona de perigo, ie, se pode ser afetado por um  laser ou por um canhao, caso possa, mover numa direcao que permita ao jogador estar em segurança
-- 2 - Verificar se algum jogador está num raio de 3 quadrados, caso se verifique usar choque e consequentemente na próxima jogada disparar laser/canhao (se estiver alinhado com o jogador, caso não esteja mudar a direção)
-- 3 - Verificar se algum jogador esta na mesma "linha" que o jogador, e se sim, disparar um laser
-- 4 - Calcular quantos blocos destrutiveis existem na direção do jogador, caso sejam bastantes disparar laser
-- 5 - Caso não reuna nenhuma das condições anteriores mover numa direção de modo a aproximar-se de um jogador

(<.) :: Maybe a -> Maybe a -> Maybe a
(<.) Nothing Nothing = Nothing
(<.) Nothing (Just x) = Just x
(<.) (Just x) _ = Just x

deleteN :: Int -> [a] -> [a]
deleteN _ []     = []
deleteN i (a:as) | i == 0    = as   
                 | otherwise = a : deleteN (i-1) as

-- * Funções principais da Tarefa 6.

dangerZoneLaser :: (Estado,Int) -> Maybe Jogada
dangerZoneLaser b@(e,ind) = if null semInversos
                               then Nothing
                               else Just $ Movimenta betterMove
  where
    (allPlayers, bot) = (jogadoresEstado e, allPlayers !! ind)
    botPos            = asSqr . posicaoJogador $ bot
    (pathNC,path)     = (pathCalculator b, pathNC >>= id)
    semBot            = deleteN ind allPlayers
    lDir              = (mapMaybe (flip runAwayLaser botPos) $ zip pathNC semBot) >>= id
    (l, semInversos)  = (nub $ lDir, [C,D,B,E] \\ l)
    betterMove        = if (direcaoJogador bot) `elem` semInversos then direcaoJogador bot else head semInversos
    
runAwayLaser :: ([Posicao], Jogador) -> [Posicao] -> Maybe [Direcao]
runAwayLaser (p,j) jPos = if any (flip elem p) jPos
                               then Just $ [direcaoJogador j, direcaoInversa . direcaoJogador $ j]
                               else Nothing

direcaoInversa :: Direcao -> Direcao
direcaoInversa = toEnum . (flip mod 4) . (+2) . fromEnum

pathCalculator :: (Estado,Int) -> [[Posicao]]
pathCalculator (e,ind) = path
  where
    allPos            = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup       = groupN allPos $ length . head . mapaEstado $ e
    allI              = posIndestrutivel (mapaEstado e) allPosGroup
    alivePlayers      = filter (\x -> vidasJogador x /= 0) $ jogadoresEstado e
    tuplo             = deleteN ind alivePlayers >>= return . posDir
    path              = map (flip allPosPath allI) $ map (uncurry shotAsTwoBlocks) tuplo 

posDir :: Jogador -> (PosicaoGrelha,Direcao)
posDir (Jogador p d _ _ _) = (p,d)

dangerZoneCanhoes :: (Estado, Int) -> Bool
dangerZoneCanhoes (e,ind) = any (flip elem inDanger) allDispPos
  where
    allCanhoes        = filter (\d -> case d of {DisparoCanhao{} -> True; _ -> False}) $ disparosEstado e
    (allPlayers, bot) = (jogadoresEstado e, allPlayers !! ind)
    inDanger          = radiusBlock (posicaoJogador bot) (mapaEstado e)
    allDispPos        = map posicaoDisparo allCanhoes

radiusBlock :: PosicaoGrelha -> Mapa -> [PosicaoGrelha]
radiusBlock (li,co) mapa = [(l,c) | l <- [linhaI..linhaF], c <- [colunaI..colunaF]]
  where
    linhaI  = if (li - 2) < 0 then 0 else li -2
    linhaF  = if (li + 2) < (pred . length $ mapa) then li +2 else pred . length $ mapa
    colunaI = if (co - 2) < 0 then 0 else co -2
    colunaF = if (co + 2) < (pred .length . head $ mapa) then co +2 else pred . length . head $ mapa

inChoque :: (Estado, Int) -> Bool
inChoque (e,ind) = any (flip elem pos) allpPos
  where
    (allPlayers, bot) = (jogadoresEstado e, allPlayers !! ind)
    pos               = posAfetadasPorChoques (posicaoJogador bot) (mapaEstado e)
    allpPos           = map posicaoJogador allPlayers

shootToKill :: (Estado,Int) -> Bool
shootToKill (e,ind) = any (flip elem allPlayersPos) path
  where
    (allPlayers, bot) = (jogadoresEstado e, allPlayers !! ind)
    allPos            = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup       = groupN allPos $ length . head . mapaEstado $ e
    allI              = posIndestrutivel (mapaEstado e) allPosGroup
    path              = flip allPosPath allI $ (uncurry shotAsTwoBlocks) . posDir $ bot 
    allPlayersPos     = concatMap (asSqr . posicaoJogador) allPlayers

howManyDestructable :: (Estado,Int) -> ([Posicao],[Posicao])
howManyDestructable (e,ind) = (allPiecesD, path)
  where
    (allPlayers, bot) = (jogadoresEstado e, allPlayers !! ind)
    allPos            = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup       = groupN allPos $ length . head . mapaEstado $ e
    allI              = posIndestrutivel (mapaEstado e) allPosGroup
    path              = flip allPosPath allI $ (uncurry shotAsTwoBlocks) . posDir $ bot 
    allPiecesD        =  mapMaybe (findPieceDest (mapaEstado e)) path

findPieceDest :: Mapa -> Posicao -> Maybe Posicao
findPieceDest m p@(l,c) = if (m !! l !! c) == (Bloco Destrutivel)
                         then Just p
                         else Nothing

-- | Define um ro'bot' capaz de jogar autonomamente o jogo.
bot :: Int          -- ^ O identificador do 'Jogador' associado ao ro'bot'.
    -> Estado       -- ^ O 'Estado' para o qual o ro'bot' deve tomar uma decisão.
    -> Maybe Jogada -- ^ Uma possível 'Jogada' a efetuar pelo ro'bot'.
--bot ind e = verificaDisparoLaser e ind 
  {-
verificaDisparoLaser :: Estado -> Int -> Maybe Jogada
verificaDisparoLaser e ind = if verificaSeAtingido pos posAfetadas then Just (Movimenta D) else Nothing
    where
        listJog  = jogadoresEstado e 
        (Jogador pos dir v l c) = listJog !! ind
        allPos                  = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
        allPosGroup             = groupN allPos $ length . head . mapaEstado $ e
        (allI, allD)            = (posIndestrutivel (mapaEstado e) allPosGroup, posDestrutivel (mapaEstado e) allPosGroup)
        posAfetadas             = vdisparoLaseraux allI e 

verificaSeAtingido :: Posicao -> [[Posicao]] -> Bool
verificaSeAtingido pos l = foldr (||) False (aux pos l)
    where
        aux :: Posicao -> [[Posicao]] -> [Bool]
        aux pos [] = []
        aux pos (h:t) = (pos `elem` h) :  aux pos t 

vdisparoLaseraux :: [Posicao] -> Estado -> [[PosicaoGrelha]]
vdisparoLaseraux allI e = if null allLaser then [] else aux allLaser allI 
    where
        listJog  = jogadoresEstado e 
        allLaser = filter (\e -> case e of {DisparoLaser{} -> True; _ -> False}) $ disparosEstado e
        aux :: [Disparo] -> [Posicao] -> [[PosicaoGrelha]]
        aux [] _ = []
        aux allLaser allI = [laserPath ((posicaoDisparo . head $ allLaser),direcaoDisparo . head $ allLaser) allI] ++ aux (tail allLaser) allI
        -}
