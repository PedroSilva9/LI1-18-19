-- | Este módulo define funções comuns da Tarefa 4 do trabalho prático.
module Tarefa4_2018li1g027 where

import LI11819
import TestesT3
import Tarefa2_2018li1g027
import Tarefa1_2018li1g027
import Data.List
import Data.Maybe

-- * Testes
-- | Testes unitários da Tarefa 4.
--
-- Cada teste é um 'Estado'.
testesT4 :: [Estado]
testesT4 = test

asSqr = (\(a,b) -> [(a,b),(a+1,b),(a,b+1),(a+1,b+1)])
asTwo = (\d -> fst $ shotAsTwoBlocks (posicaoDisparo d) (direcaoDisparo d))

-- * Funções principais da Tarefa 4.

-- | Avança o 'Estado' do jogo um 'Tick' de tempo.
--
-- __NB:__ Apenas os 'Disparo's afetam o 'Estado' do jogo com o passar do tempo.
--
-- __NB:__ Deve chamar as funções 'tickChoques', 'tickCanhoes' e 'tickLasers' pela ordem definida.
tick :: Estado -- ^ O 'Estado' anterior.
     -> Estado -- ^ O 'Estado' após um 'Tick'.
tick = tickChoques . tickCanhoes . tickLasers

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos tiros de 'Laser' disparados.
tickLasers :: Estado -> Estado
tickLasers e = atualizaDisparosLaser $ flip verifiesTanks path $ verifiesDestructable rmCanhoes path allD 
  where
    allLasers = filter (\e -> case e of {DisparoLaser{} -> True; _ -> False}) $ disparosEstado e
    allCanhoes = filter (\e -> case e of {DisparoCanhao{} -> True; _ -> False}) $ disparosEstado e
    tuploPosDir = zip (map posicaoDisparo allLasers) (map direcaoDisparo allLasers)
    tuploAsTwoPos = map (uncurry shotAsTwoBlocks) tuploPosDir
    allPos = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup = groupN allPos $ length . head . mapaEstado $ e
    (allI, allD) = (posIndestrutivel (mapaEstado e) allPosGroup, posDestrutivel (mapaEstado e) allPosGroup)
    path = nub . concat $ map (flip allPosPath allI) tuploAsTwoPos
    rmCanhoes = verifiesCanhoes e $ concat $ map (flip laserPath allI) tuploPosDir

atualizaDisparosLaser :: Estado -> Estado
atualizaDisparosLaser e = let newDisp = filter (\e -> case e of {DisparoLaser{} -> False; _ -> True}) $ disparosEstado e
                          in e{disparosEstado = newDisp}

verifiesCanhoes :: Estado -> [Posicao] -> Estado
verifiesCanhoes e l = e{disparosEstado = aux (disparosEstado e) l}
  where
    aux :: [Disparo] -> [Posicao] -> [Disparo]
    aux [] _ = []
    aux (d@(DisparoCanhao _ pos _) : t) l = if elem pos l then aux t l else d : aux t l
    aux (h:t) l = h : aux t l


verifiesTanks :: Estado -> [Posicao] -> Estado
verifiesTanks e path = e{jogadoresEstado = aux allPlayers path}
  where
    allPlayers = jogadoresEstado e
    aux :: [Jogador] -> [Posicao] -> [Jogador]
    aux [] _ = []
    aux (h:t) pos = let vidas = vidasJogador h 
                    in if (any id $ map (flip elem pos) (asSqr . posicaoJogador $ h)) && vidas > 0
                          then h{vidasJogador = pred vidas} : aux t pos
                          else h : aux t pos

verifiesDestructable :: Estado -> [Posicao] -> [Posicao] -> Estado
verifiesDestructable e path dest = e{mapaEstado = aux intersection mapa}
  where
    intersection = intersect path dest
    mapa = mapaEstado e
    aux :: [Posicao] -> Mapa -> Mapa
    aux [] m = m
    aux (h:t) m = aux t (atualizaPosicaoMatriz h Vazia m)

laserPath :: (PosicaoGrelha,Direcao) -> [Posicao] -> [PosicaoGrelha] 
laserPath (x,C) posInd = [(l,snd x) | l <- [maxRow .. fst x]]
  where
    sameColumn = filter (\(a,b) -> b == snd x && a < fst x) posInd
    maxRow = maximum $ map fst sameColumn
laserPath (x,D) posInd = [(fst x,c) | c <- [snd x .. minColumn]]
  where
    sameRow = filter (\(a,b) -> a == fst x && b > snd x) posInd
    minColumn = minimum $ map snd sameRow
laserPath (x,B) posInd = [(l,snd x) | l <- [fst x .. minRow]]
  where
    sameColumn = filter (\(a,b) -> b == snd x && a > fst x) posInd
    minRow = minimum $ map fst sameColumn
laserPath (x,E) posInd = [(fst x,c) | c <- [maxColumn .. snd x]]
  where
    sameRow = filter (\(a,b) -> a == fst x && b < snd x) posInd
    maxColumn = maximum $ map snd sameRow

--para cada disparo recebe a lista de pos e a dir e recebe a posicao dos indestrutiveis e retorna o caminho entre a posicao de disparo e a peca indestrutivel mais proxima.
allPosPath :: ([Posicao],Direcao) -> [Posicao] -> [Posicao] 
allPosPath ((x:xs:t),C) posInd = [(l,snd x) | l <- [maxRow .. fst x]] ++ [(l,snd xs) | l <- [maxRow .. fst xs]] 
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x && a < fst x) posInd, filter (\(a,b) -> b == snd xs && a < fst x) posInd)
    maxRow = max (maximum $ map fst sameColumnFst) (maximum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),D) posInd = [(fst x,c) | c <- [snd x .. minColumn]] ++ [(fst xs,c) | c <- [snd xs .. minColumn]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x && b > snd x) posInd, filter (\(a,b) -> a == fst xs && b > snd x) posInd)
    minColumn = min (minimum $ map snd sameRowFst) (minimum $ map snd sameRowSnd)
allPosPath ((x:xs:t),B) posInd = [(l,snd x) | l <- [fst x .. minRow]] ++ [(l,snd xs) | l <- [fst xs .. minRow]]
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x && a > fst x) posInd, filter (\(a,b) -> b == snd xs && a > fst x) posInd)
    minRow = min (minimum $ map fst sameColumnFst) (minimum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),E) posInd = [(fst x,c) | c <- [maxColumn .. snd x]] ++ [(fst xs,c) | c <- [maxColumn .. snd xs]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x && b < snd x) posInd, filter (\(a,b) -> a == fst xs && b < snd x) posInd)
    maxColumn = max (maximum $ map snd sameRowFst) (maximum $ map snd sameRowSnd)

shotAsTwoBlocks :: PosicaoGrelha -> Direcao -> ([Posicao], Direcao)
shotAsTwoBlocks (li,co) C = ([(li,co), (li,succ co)], C)
shotAsTwoBlocks (li,co) B = ([(succ li, co), (succ li, succ co)], B)
shotAsTwoBlocks (li,co) D = ([(li, succ co), (succ li, succ co)], D)
shotAsTwoBlocks (li,co) E = ([(li,co), (succ li,co)], E)

groupN :: [a] -> Int -> [[a]]
groupN [] _ = []
groupN l n = take n l : groupN (drop n l) n

posIndestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posIndestrutivel [] [] = []
posIndestrutivel (x:xs) (y:ys) = aux x y ++ posIndestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Indestrutivel) then y : aux xs ys else aux xs ys

posDestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posDestrutivel [] [] = []
posDestrutivel (x:xs) (y:ys) = aux x y ++ posDestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Destrutivel) then y : aux xs ys else aux xs ys

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos das balas de 'Canhao' disparadas.

tickCanhoes :: Estado -> Estado
tickCanhoes e = let newEstado = verifiesDestructable (checkTanks e removeInd) shotsAsTwoPos allD
                    disps = disparosEstado newEstado
                in newEstado{disparosEstado = map avancaDisparo disps}
  where
    allCanhoes = filter (\e -> case e of {DisparoCanhao{} -> True; _ -> False}) $ disparosEstado e
    tuploPosDir = zip (map posicaoDisparo $ allCanhoes) (map direcaoDisparo allCanhoes)
    shotsAsTwoPos = concat $ map fst $ map (uncurry shotAsTwoBlocks) tuploPosDir
    allPos = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup = groupN allPos $ length . head . mapaEstado $ e
    (allI, allD) = (posIndestrutivel (mapaEstado e) allPosGroup, posDestrutivel (mapaEstado e) allPosGroup)
    disparos = removeSobrepostos (map posicaoDisparo allCanhoes) $ justPassed tuploPosDir allCanhoes
    removeDest = removeCanhao disparos $ intersect shotsAsTwoPos allD
    removeInd = removeCanhao removeDest $ intersect shotsAsTwoPos allI

avancaDisparo :: Disparo -> Disparo
avancaDisparo d@(DisparoCanhao _ pos dir) = let newPos = somaVetores pos $ direcaoParaVetor dir
                                            in d{posicaoDisparo = newPos}
avancaDisparo d = d 

checkTanks :: Estado -> [Disparo] -> Estado
checkTanks e lDisp = e{jogadoresEstado = newJog, disparosEstado = newDisp}
  where
    (players,disparos) = (jogadoresEstado e, filter (\e -> case e of {DisparoCanhao{} -> False; _ -> True}) $ disparosEstado e)
    (newJog,disp) = (atualizaJog players lDisp, atualizaDisp players lDisp)
    newDisp = disparos ++ disp

atualizaJog :: [Jogador] -> [Disparo] -> [Jogador]
atualizaJog j d = atualizaJogAux j (concat $ map asTwo d)
  where
    asTwo = (\d -> fst $ shotAsTwoBlocks (posicaoDisparo d) (direcaoDisparo d))

atualizaJogAux :: [Jogador] -> [Posicao] -> [Jogador]
atualizaJogAux [] _ = []
atualizaJogAux (h:t) lp = if any id $ map (flip elem lp) asTank
                             then if vidasJogador h /= 0 
                                     then removeVidas h : t 
                                     else h : t
                             else h : atualizaJogAux t lp
  where
    asTank = asSqr . posicaoJogador $ h
    removeVidas :: Jogador -> Jogador
    removeVidas j = let vidas = vidasJogador j
                    in if vidas /= 0
                          then j{vidasJogador = pred vidas}
                          else j

atualizaDisp :: [Jogador] -> [Disparo] -> [Disparo]
atualizaDisp j d = catMaybes $ map (aux allJPos) d
  where
    comVida = filter (\j -> vidasJogador j /= 0) j
    allJPos = concat $ map asSqr $ map posicaoJogador comVida
    aux :: [Posicao] -> Disparo -> Maybe Disparo
    aux allJPos d = let dispPos = fst $ shotAsTwoBlocks (posicaoDisparo d) (direcaoDisparo d)
                    in if any id $ map (flip elem allJPos) dispPos
                          then Nothing
                          else Just d

--lista de disparos; shotsAsTwoPos; asSqr; Jogador
checkTanksAux :: (Disparo,[Posicao]) -> ([Posicao],Jogador) -> (Jogador,Maybe Disparo)
checkTanksAux (disp,asTwo) (asSqr, j) = let vidas = vidasJogador j
                                        in if any id $ map (flip elem asTwo) asSqr 
                                           then if (vidas == 0) then (j,Nothing) else (j{vidasJogador = pred vidas}, Nothing)
                                           else (j,Just disp)

--remove os canhoes que embateram com as peças
removeCanhao :: [Disparo] -> [Posicao] -> [Disparo]
removeCanhao lDisp l = catMaybes $ map (aux l) lDisp
  where
    aux :: [Posicao] -> Disparo -> Maybe Disparo
    aux l d = if any id $ map (flip elem l) $ asTwo d then Nothing else Just d

atualizaDisparosCanhao :: Estado -> [Disparo] -> Estado
atualizaDisparosCanhao e d = e{disparosEstado = d}

justPassed :: [(Posicao,Direcao)] -> [Disparo] -> [Disparo]
justPassed tuplo lDisps = catMaybes $ map (aux tuploShot) lDisps
  where
    oppositeDirMap = map (toEnum . flip mod 4 . (+) 2 . fromEnum . direcaoDisparo) lDisps
    oppositePosMap = map (uncurry somaVetores) $ zip (map posicaoDisparo lDisps) (map direcaoParaVetor oppositeDirMap)
    tuploShot = zip oppositePosMap oppositeDirMap
    aux :: [(Posicao,Direcao)] -> Disparo -> Maybe Disparo
    aux tuploOpposite disp = let tuplo = (posicaoDisparo disp, direcaoDisparo disp)
                             in if elem tuplo tuploOpposite then Nothing else Just disp

removeSobrepostos :: [PosicaoGrelha] -> [Disparo] -> [Disparo]
removeSobrepostos allPos lDisp = catMaybes $ map (sameSpot allPos) lDisp
  where
    sameSpot :: [PosicaoGrelha] -> Disparo -> Maybe Disparo
    sameSpot allPos disp = let dispPos = posicaoDisparo disp
                           in if (length $ filter (==dispPos) allPos) > 1 then Nothing else Just disp
                        
-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos campos de 'Choque' disparados.
tickChoques :: Estado -> Estado
tickChoques e = e{disparosEstado = nChoques ++ newTicks}
  where
    (choques, nChoques) = partition (\e -> case e of {DisparoChoque{} -> True; _ -> False}) $ disparosEstado e
    newTicks = catMaybes $ map atualizaTicks choques

atualizaTicks :: Disparo -> Maybe Disparo
atualizaTicks d = let tick = tempoDisparo d 
                  in if tick == 0
                        then Nothing
                        else Just d{tempoDisparo = pred tick}
