{-|
Module      : DesenhaJogo
Description : Modulo integrante da Tarefa 5 do projeto a desenvolver no âmbito da unidade curricular LI1.
Copyright   : José Pedro Silva <a84577@uminho.pt>
              Rui Carvalho <a89498@uminho.pt>
Porção de código da tarefa 5 que permite desenhar o jogo, mais precisamente, os tanques, o mapa, os tiros e toda a informação relativa ao estado dos jogadores.

Permite também desenhar o construtor de mapas no ecrã, bem como o tetrómino e todo o seu movimento e as intruções de como utilizá-lo.
-}
module DesenhaJogo where

import LI11819
import Typos
import Data.List (nub)
import Data.Char (digitToInt)
import Tarefa4_2018li1g027 (groupN,posIndestrutivel,laserPath,shotAsTwoBlocks,allPosPath)
import Graphics.Gloss.Interface.Pure.Game

{- | Função que apaga um elemento num determinado índice de uma lista.

=== Exemplo de utilização:
>>> deteleN 2 [1,2,3,4] = [1,2,4]
-}

deleteN :: Int -> [a] -> [a]
deleteN _ []     = []
deleteN i (a:as) | i == 0    = as   
                 | otherwise = a : deleteN (i-1) as

{- | Função que mediante os valores lógicos das variáveis 'menu' e 'criaMapa' desenha imagens na tela do jogo.

Se o valor de 'menu' do 'EstadoGloss' for verdade então o utilizador está no menu e o programa faz aparecer a imagem do menu que se encontra no 'tMenu' atual.

Se o 'criaMapa' for verdade e o 'menu' falso então a função 'desenhaCriaMapa' passando como argumento o mapa do 'editor' e o 'EstadoGloss' atual.

Se Nenhum dos anteriores for verdade então quer dizer que o utilizador se encontra realmente no jogo e chama a função 'desenhaJogo' passando o 'EstadoGloss' como argumento

-}
desenhaEstado :: EstadoGloss -> Picture
desenhaEstado e | menu e = tMenu e
                | criaMapa e = desenhaCriaMapa (mapaEditor . editor $ e) e
                | otherwise = desenhaJogo e



desenhaCriaMapa :: Mapa -> EstadoGloss -> Picture
desenhaCriaMapa m e = if criaM then Pictures getList else Pictures getMapaPic 
  where
    (bSize,pixelSize) = pecaSize e m
    criaM             = criaMapa e 
    (posX,posY)       = changeReferencial e m -- Mudar isto
    getInfo           = desenhaInfoCM e
    getMapaPic        = desenhaMapa m posX posY bSize pixelSize e
    getList           = getMapaPic ++ [getInfo]

desenhaInfoCM :: EstadoGloss -> Picture
desenhaInfoCM e = translatedPic
  where pic                    = last . imagensMenu . imagens $ e 
        mapa                   = mapaEstado . estado $ e 
        (x,y)                  = windowSize e 
        (sizePs,realPixelSize) = changeReferencial e mapa
        espaco                 = ((fromIntegral x) - 500 - realPixelSize * (fromIntegral (length . head $ mapa)))/3
        resize                 = espaco / 1400
        sizePx                 = resize * 700
        resizePic              = Scale (resize) resize pic 
        translatedPic          = Translate (fromIntegral x/2 -sizePx/2) 0 resizePic

pecaSize :: EstadoGloss -> Mapa -> (Float,Float)
pecaSize e m = (bestSize, pixelPecaSize)
  where
    (a,b)         = windowSize e
    (tlinha,tcol) = (length . head $ m, length m)
    sizePecaX     = fromIntegral a *0.5 / fromIntegral (tlinha * 100)
    sizePecaY     = fromIntegral b *0.8 / fromIntegral (tcol * 100)
    bestSize      = if sizePecaY > sizePecaX then sizePecaX else sizePecaY
    pixelPecaSize = bestSize * 100

--Mudanca de referencial?
changeReferencial :: EstadoGloss -> Mapa -> (Float,Float)
changeReferencial e m = (-posX,-posY)
  where
    pixelPecaSize = snd $ pecaSize e m
    (tlinha,tcol) = (length . head $ m, length m)
    (posX,posY)   = ((pixelPecaSize * fromIntegral tlinha) / 2 - (pixelPecaSize / 2), (pixelPecaSize * fromIntegral tcol / 2) - (pixelPecaSize / 2))

--Melhor Posicao Para o tanque
posTank :: EstadoGloss -> [Jogador]
posTank e = listjog
  where
    mapa    = mapaEstado . estado $ e
    (li,co) = (length mapa, length . head $ mapa)
    jog1    = Jogador (bestPosTank e (0,0))   B 5 5 5
    jog2    = Jogador (bestPosTank e (li,co)) C 5 5 5
    jog3    = Jogador (bestPosTank e (0,co))  E 5 5 5
    jog4    = Jogador (bestPosTank e (li,0))  D 5 5 5
    listjog = [jog1,jog2,jog3,jog4]

bestPosTank :: EstadoGloss -> Posicao -> Posicao
bestPosTank e (x,y) = calculaPosMaisProx (x,y) listPosVazias
  where
    m             = mapaEstado . estado $ e
    listPosVazias = checkPosVazia m

checkPosVazia :: Mapa -> [Posicao]
checkPosVazia m = posOndeCabemTanques $ posVazia m allPosGroup
  where
    allPos      = [(l,c) | l <- [0 .. pred . length $ m], c <- [0 .. pred . length . head $ m]]
    allPosGroup = groupN allPos $ length . head $ m

posOndeCabemTanques :: [Posicao] -> [Posicao]
posOndeCabemTanques [] = []
posOndeCabemTanques ((a,b):t) = if (a+1,b) `elem` ((a,b):t) && (a+1,b+1) `elem` ((a,b):t) && (a,b+1) `elem` ((a,b):t) 
                                   then (a,b): posOndeCabemTanques t
                                   else posOndeCabemTanques t

posVazia :: Mapa -> [[Posicao]] -> [Posicao]
posVazia [] [] = []
posVazia (x:xs) (y:ys) = aux x y ++ posVazia xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if x == Vazia then y : aux xs ys else aux xs ys

calculaPosMaisProx :: Posicao -> [Posicao] -> Posicao
calculaPosMaisProx pos listPos = if null listPos then (0,0) else listPos !! distMenor (map (aux pos) listPos)
  where
    aux :: Posicao -> Posicao -> Float
    aux (x,y) h = dist (x,y) h

distMenor :: [Float] -> Int
distMenor [] = -1
distMenor (h:t) = aux h 0 1 t
  where
    aux vm indmin indreal [] = indmin
    aux vm indmin indreal (x:xs) | x < vm    = aux x indreal (succ indreal) xs
                                 | otherwise = aux vm indmin (succ indreal) xs

dist :: Posicao -> Posicao -> Float
dist (a,b) (x,y) = sqrt $ fromIntegral (y-b)^2 + fromIntegral (x-a)^2                      

-- | Funcão que desenha o mapa 
desenhaMapa :: Mapa -> Float -> Float -> Float -> Float -> EstadoGloss -> [Picture]
desenhaMapa [] _ _ _ _ _= []
desenhaMapa (h:t) posx posy bestSizeToScale pixelPecaSize e = pic : desenhaMapa t posx (posy+pixelPecaSize) bestSizeToScale pixelPecaSize e
  where
    pic = Translate posx (-posy) $ Pictures $ desenhaLinha e 0 pixelPecaSize bestSizeToScale h

desenhaLinha :: EstadoGloss -> Float -> Float -> Float -> [Peca] -> [Picture]
desenhaLinha e _ _ _ [] = []
desenhaLinha e posI sizePixelPeca sizePecaToScale (h:t) = pic : desenhaLinha e (posI+sizePixelPeca) sizePixelPeca sizePecaToScale t
  where
    pic = Translate posI 0 $ Scale sizePecaToScale sizePecaToScale $ desenhaPeca e h

desenhaPeca :: EstadoGloss -> Peca -> Picture
desenhaPeca e (Bloco Indestrutivel) = head . imagensJogo . imagens $ e
desenhaPeca e (Bloco Destrutivel)   = (imagensJogo . imagens $ e) !! 1
desenhaPeca e Vazia                 = (imagensJogo . imagens $ e) !! 2

-- | Função que desenha todos os elementos do jogo, sendo que, vai buscar as diferentes pictures às funcoes correspondestes agrupando-as numa só lista e recorrendo à função Pictures forma só uma picture.
desenhaJogo :: EstadoGloss -> Picture
desenhaJogo e = Pictures list
  where 
    mapa    = mapaEstado . estado $ e
    picMapa = desenhaCriaMapa mapa e
    tanques = Pictures $ desenhaTanques e
    tiros   = Pictures $ desenhaTiro e
    powerUP = Pictures $ desenhaPowerUps e
    ticks   = drawTicksCounter e
    estados = getEstados e 
    list    = [picMapa,tanques,tiros,powerUP,ticks,estados]

-- | Função
desenhaTanques :: EstadoGloss -> [Picture]
desenhaTanques e = aux e listJogadores listPictures
  where
    (listPictures, listJogadores) = (pictureTank e, jogadoresEstado . estado $ e)
    aux :: EstadoGloss -> [Jogador] -> [Picture] -> [Picture]
    aux _ [] _ = []
    aux _ _ [] = []
    aux e (jog:jogs) (pic:pics) = if vidasJogador jog > 0
                                     then desenhaTank e jog pic : aux e jogs pics
                                     else aux e jogs pics

desenhaTank :: EstadoGloss -> Jogador -> Picture -> Picture
desenhaTank e (Jogador (x,y) dir v l c) pic = translateTank
  where
    mapa                        = mapaEstado . estado $ e
    (sizeToScale,realPixelSize) = pecaSize e mapa
    (posX,posY)                 = changeReferencial e mapa
    resizeTank                  = scale (sizeToScale*2) (sizeToScale*2) pic
    rotateTank                  = Rotate (direcaoToAngle dir) resizeTank
    (a,b)                       = (posX + (realPixelSize/2) +realPixelSize*fromIntegral y, posY + (realPixelSize / 2) + realPixelSize * fromIntegral x)
    translateTank               = Translate a (-b) rotateTank

direcaoToAngle :: Direcao -> Float
direcaoToAngle = realToFrac . (*) 90 . fromEnum

pictureTank :: EstadoGloss -> [Picture]
pictureTank e = take njog listTanks
  where
    njog = nJog e
    listTanks =take 4 $ drop 3 (imagensJogo.imagens $ e)

desenhaTiro :: EstadoGloss -> [Picture]
desenhaTiro e = map (aux e) newDispList
  where
    listDisp = disparosEstado . estado $ e
    lasers   = filter (\d -> case d of {DisparoLaser{} -> True; _ -> False}) listDisp
    other    = filter (\d -> case d of {DisparoLaser{} -> False; _ -> True}) listDisp
    newDispList = other ++ lasers 
    aux :: EstadoGloss -> Disparo -> Picture
    aux e d@(DisparoLaser n pos dir) = drawLaserPath e d
    aux e p = resizeTiro e p (pictureTiro e p)

{- | Função que permite desenhar o laser.




-}

drawLaserPath :: EstadoGloss -> Disparo -> Picture
drawLaserPath e d@(DisparoLaser n pos dir) = Pictures $ aux e d laserCaminho
  where 
    mapa              = mapaEstado . estado $ e
    joglistPos        = map posicaoJogador (jogadoresEstado .estado $ e)
    semJog            = deleteN n joglistPos 
    allPos            = [(l,c) | l <- [0 .. pred . length $ mapa], c <- [0 .. pred . length . head $ mapa]]
    allPosGroup       = groupN allPos $ length . head $ mapa
    allI              = posIndestrutivel mapa allPosGroup
    laser             = tail $ laserPath (pos,dir) allI 
    tuploAsTwoPos     = map (uncurry shotAsTwoBlocks) [(pos,dir)]
    (pathNC, path)    = (map (flip allPosPath allI) tuploAsTwoPos, nub . concat $ pathNC)
    laserCaminho      = take (div (length path) 2) path
    aux e d [] = []
    aux e d@(DisparoLaser n pos dir) (h:t) = resizeTiro e d (pictureTiro e d) : aux e (DisparoLaser n h dir) t

resizeTiro :: EstadoGloss -> Disparo -> Picture -> Picture
resizeTiro e (DisparoChoque jog tick) pic = translateChoque
  where
    mapa                        = mapaEstado . estado $ e
    (sizeToScale,realPixelSize) = pecaSize e mapa
    (posX,posY)                 = changeReferencial e mapa
    resTiroChoque               = scale sizeToScale sizeToScale pic
    (Jogador (a,b) dir v l c)   = (jogadoresEstado . estado $ e) !! jog
    (i,j)                       = (posX + (realPixelSize / 2) + realPixelSize*fromIntegral b, posY + (realPixelSize / 2) + realPixelSize * fromIntegral a)
    translateChoque             = Translate i (-j) resTiroChoque
resizeTiro e d pic = translCL
  where
    mapa                        = mapaEstado . estado $ e
    ((x,y), dir)                = (posicaoDisparo d,direcaoDisparo d)
    (sizeToScale,realPixelSize) = pecaSize e mapa
    (posX,posY)                 = changeReferencial e mapa
    resTiroCL                   = scale (sizeToScale/2) sizeToScale pic
    rotateCL                    = rotate (direcaoToAngle dir) resTiroCL
    (a,b)                       = (posX +(realPixelSize/2)+realPixelSize*fromIntegral y, posY + (realPixelSize/2) + realPixelSize*fromIntegral x)
    translCL                    = Translate a (-b) rotateCL

pictureTiro :: EstadoGloss -> Disparo -> Picture
pictureTiro e (DisparoCanhao jog _ _) = (imagensJogo . imagens $ e) !! (jog + 7)
pictureTiro e (DisparoLaser jog _ _)  = (imagensJogo . imagens $ e) !! (jog + 11)
pictureTiro e (DisparoChoque jog _)   = (imagensJogo . imagens $ e) !! (jog + 15)

drawTicksCounter :: EstadoGloss -> Picture
drawTicksCounter e = Pictures $ aux (reverse listcharTick) 0 e
  where
    listcharTick = show . tickCounter $ e
    aux [] _ _ = []
    aux (h:t) n e = desenhaTick e n (pictureTick e h) : aux t (n+1.0) e

desenhaTick :: EstadoGloss -> Float -> Picture -> Picture
desenhaTick e n pic = translateTick
  where
    mapa                        = mapaEstado . estado $ e
    (x,y)                       = windowSize e
    (sizeToScale,realPixelSize) = pecaSize e mapa
    newEspacoForTick            = (fromIntegral y - realPixelSize * (fromIntegral . length $ mapa))/4
    scaleNewEspaco              = newEspacoForTick/fromIntegral y
    resTickPic                  = scale scaleNewEspaco scaleNewEspaco pic
    pixelSizeOfTick             = scaleNewEspaco * 600
    sumTranslate                = n * pixelSizeOfTick
    translateTick               = Translate (-sumTranslate + pixelSizeOfTick) ((-realPixelSize * (fromIntegral . length $ mapa))/2 - pixelSizeOfTick/1.5) resTickPic 

pictureTick :: EstadoGloss -> Char -> Picture
pictureTick e c = let numero = digitToInt c
                  in (imagensTickCounter . imagens $ e) !! numero


desenhaPowerUps :: EstadoGloss -> [Picture]
desenhaPowerUps e = map (aux e) listpowerup
  where
    listpowerup = powerups e
    aux :: EstadoGloss -> Powerup -> Picture
    aux e p = resizePowerUp e p (picturePowerUp e p)

resizePowerUp :: EstadoGloss -> Powerup -> Picture -> Picture
resizePowerUp e powerup pic = translatePU
  where
    mapa                        = mapaEstado . estado $ e
    (sizeToScale,realPixelSize) = pecaSize e mapa
    (posX,posY)                 = changeReferencial e mapa
    resPU                       = scale (sizeToScale/8) ( sizeToScale/8) pic
    (a,b)                       = posicaoPowerUp powerup
    (i,j)                       = (posX + (realPixelSize / 2) +realPixelSize * fromIntegral b , posY + (realPixelSize / 2) + realPixelSize*fromIntegral a)
    translatePU                 = Translate i (-j) resPU

picturePowerUp :: EstadoGloss -> Powerup -> Picture
picturePowerUp e (PowerupLasers _)    = head . imagensPowerUps . imagens $ e
picturePowerUp e (PowerupChoques _)   = (imagensPowerUps . imagens $ e) !! 1
picturePowerUp e (PowerupTeleport _)  = (imagensPowerUps . imagens $ e) !! 2
picturePowerUp e (PowerupVida _)      = (imagensPowerUps . imagens $ e) !! 3

getEstados :: EstadoGloss -> Picture
getEstados e = Pictures $ aux listJog 0 e
  where 
    listJog = jogadoresEstado . estado $ e 
    aux :: [Jogador] -> Int -> EstadoGloss -> [Picture]
    aux [] _ _ = []
    aux (h:t) a e = desenhaEstadoJog e a : aux t (a+1) e 

desenhaEstadoJog :: EstadoGloss -> Int -> Picture
desenhaEstadoJog e n = case n of 
                         0 -> desenhaInfo 0 a b sizeOfPixelEstado e $ Translate a b resizeEstado
                         1 -> desenhaInfo 1 a (-b)  sizeOfPixelEstado e $ Translate a (-b) resizeEstado
                         2 -> desenhaInfo 2 (-a) b sizeOfPixelEstado e $ Translate (-a) b resizeEstado
                         3 -> desenhaInfo 3 (-a) (-b) sizeOfPixelEstado e $ Translate (-a) (-b) resizeEstado
  where
    mapa               = mapaEstado . estado $ e
    pic                = estadoJog n e  
    (x,y)              = windowSize e
    (sizePeca,pixelPS) = pecaSize e mapa
    newEspacoForEstado = (fromIntegral x-pixelPS * (fromIntegral . length . head $ mapa))/2
    newSizeToResize    = newEspacoForEstado / 900
    sizeOfPixelEstado  = newSizeToResize * 600      
    resizeEstado       = scale newSizeToResize newSizeToResize pic
    (a,b)              = (fromIntegral x /2 - sizeOfPixelEstado / 2,fromIntegral y / 2 - sizeOfPixelEstado/1.5)

estadoJog :: Int -> EstadoGloss -> Picture
estadoJog n e = pics !! (n+19)
  where pics = imagensJogo . imagens $ e

desenhaInfo :: Int -> Float -> Float -> Float -> EstadoGloss-> Picture -> Picture
desenhaInfo n a b sizeOfPixelEstado e pic = Pictures [pic,infoAfterResize]
  where 
    jog    = flip (!!) n . jogadoresEstado . estado $ e
    vidas  = show . vidasJogador $ jog
    laser  = show . lasersJogador $ jog
    choque = show . choquesJogador $ jog
    infoAfterResize = resizeVLC vidas laser choque e sizeOfPixelEstado a b

resizeVLC :: String -> String -> String -> EstadoGloss -> Float -> Float -> Float -> Picture
resizeVLC vidas laser choque e spe x y = Pictures list
  where
    translateNumber  = 400 * spe / 600
    translateNumberY = 160 * spe / 400
    fator            = translateNumber / 2500
    pixelNumberSize  = fator * 600.0
    (a,b)            = windowSize e 
    scaleVidas       = fator / fromIntegral (length vidas)
    scaleLaser       = fator / fromIntegral (length laser)
    scaleChoque      = fator / fromIntegral (length choque)  
    picVida          = Pictures . reverse $ placeN e vidas 0 pixelNumberSize scaleVidas x y (-2.0)
    picLaser         = Pictures . reverse $ placeN e laser 0 pixelNumberSize scaleLaser x y (-1.0)
    picChoques       = Pictures . reverse $ placeN e choque 0 pixelNumberSize scaleChoque x y 1.5
    list             = [picVida, picLaser,picChoques]


placeN :: EstadoGloss -> String -> Int -> Float -> Float -> Float -> Float -> Float -> [Picture]
placeN _ [] _ _ _ _ _ _ = []
placeN e (h:t) n s scale x y multplicadorDeTipo = Translate a b (Scale scale scale $ pictureTick e h) : placeN e t (n+1) s scale x y multplicadorDeTipo
  where
    (a,b) = (x - s + fromIntegral n / 2 * s, y + s * multplicadorDeTipo)