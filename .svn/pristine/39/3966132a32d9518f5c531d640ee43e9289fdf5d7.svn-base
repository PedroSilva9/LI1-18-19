-- | Este módulo define funções comuns da Tarefa 4 do trabalho prático.
module Tarefa4_2018li1g027 where

import LI11819
import TestesT3
import Tarefa2_2018li1g027
import Tarefa1_2018li1g027
import Data.List

-- * Testes
-- | Testes unitários da Tarefa 4.
--
-- Cada teste é um 'Estado'.
testesT4 :: [Estado]
testesT4 = []

-- * Funções principais da Tarefa 4.

-- | Avança o 'Estado' do jogo um 'Tick' de tempo.
--
-- __NB:__ Apenas os 'Disparo's afetam o 'Estado' do jogo com o passar do tempo.
--
-- __NB:__ Deve chamar as funções 'tickChoques', 'tickCanhoes' e 'tickLasers' pela ordem definida.
tick :: Estado -- ^ O 'Estado' anterior.
     -> Estado -- ^ O 'Estado' após um 'Tick'.
tick = tickChoques . tickCanhoes . tickLasers

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos tiros de 'Laser' disparados.
tickLasers :: Estado -> Estado
tickLasers e = flip verifiesTanks allI $ verifiesDestructable e path allD 
  where
    allLasers = filter (\e -> case e of {DisparoLaser{} -> True; _ -> False}) $ disparosEstado e 
    tuploPosDir = zip (map posicaoDisparo allLasers) (map direcaoDisparo allLasers)
    tuploAsTwoPos = map (uncurry shotAsTwoBlocks) tuploPosDir
    allPos = [(l,c) | l <- [0 .. pred . length . mapaEstado $ e], c <- [0 .. pred . length . head . mapaEstado $ e]]
    allPosGroup = groupN allPos $ length . head . mapaEstado $ e
    (allI, allD) = (posIndestrutivel (mapaEstado e) allPosGroup, posDestrutivel (mapaEstado e) allPosGroup)
    path = concat $ map (flip allPosPath allI) tuploAsTwoPos

verifiesTanks :: Estado -> [Posicao] -> Estado
verifiesTanks e path = e{jogadoresEstado = aux allPlayers path}
  where
    allPlayers = jogadoresEstado e
    aux :: [Jogador] -> [Posicao] -> [Jogador]
    aux [] _ = []
    aux (h:t) pos = let vidas = vidasJogador h 
                    in if elem (posicaoJogador h) pos && vidas > 0
                          then h{vidasJogador = pred vidas} : aux t pos
                          else h : aux t pos

verifiesDestructable :: Estado -> [Posicao] -> [Posicao] -> Estado
verifiesDestructable e path dest = e{mapaEstado = aux intersection mapa}
  where
    intersection = intersect path dest
    mapa = mapaEstado e
    aux :: [Posicao] -> Mapa -> Mapa
    aux [] m = m
    aux (h:t) m = aux t (atualizaPosicaoMatriz h Vazia m)

--para cada disparo recebe a lista de pos e a dir e recebe a posicao dos indestrutiveis e retorna o caminho entre a posicao de disparo e a peca indestrutivel mais proxima.
allPosPath :: ([Posicao],Direcao) -> [Posicao] -> [Posicao] 
allPosPath ((x:xs:t),C) posInd = [(l,snd x) | l <- [maxRow .. fst x]] ++ [(l,snd xs) | l <- [maxRow .. fst xs]] 
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x) posInd, filter (\(a,b) -> b == snd xs) posInd)
    maxRow = max (maximum $ map fst sameColumnFst) (maximum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),D) posInd = [(fst x,c) | c <- [snd x .. minColumn]] ++ [(fst xs,c) | c <- [snd xs .. minColumn]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x) posInd, filter (\(a,b) -> a == fst xs) posInd)
    minColumn = min (minimum $ map snd sameRowFst) (minimum $ map snd sameRowSnd)
allPosPath ((x:xs:t),B) posInd = [(l,snd x) | l <- [fst x .. minRow]] ++ [(l,snd xs) | l <- [fst xs .. minRow]]
  where
    (sameColumnFst, sameColumnSnd) = (filter (\(a,b) -> b == snd x) posInd, filter (\(a,b) -> b == snd xs) posInd)
    minRow = min (minimum $ map fst sameColumnFst) (minimum $ map fst sameColumnSnd)
allPosPath ((x:xs:t),E) posInd = [(fst x,c) | c <- [maxColumn .. fst x]] ++ [(fst xs,c) | c <- [maxColumn .. fst xs]]
  where
    (sameRowFst, sameRowSnd) = (filter (\(a,b) -> a == fst x) posInd, filter (\(a,b) -> a == fst xs) posInd)
    maxColumn = max (maximum $ map snd sameRowFst) (maximum $ map snd sameRowSnd)

shotAsTwoBlocks :: PosicaoGrelha -> Direcao -> ([Posicao], Direcao)
shotAsTwoBlocks (li,co) C = ([(li,co), (li,succ co)], C)
shotAsTwoBlocks (li,co) B = ([(succ li, co), (succ li, succ co)], B)
shotAsTwoBlocks (li,co) D = ([(li, succ co), (succ li, succ co)], D)
shotAsTwoBlocks (li,co) E = ([(li,co), (succ li,co)], E)

groupN :: [a] -> Int -> [[a]]
groupN [] _ = []
groupN l n = take n l : groupN (drop n l) n

posIndestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posIndestrutivel [] [] = []
posIndestrutivel (x:xs) (y:ys) = aux x y ++ posIndestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Indestrutivel) then y : aux xs ys else aux xs ys

posDestrutivel :: Mapa -> [[Posicao]] -> [Posicao]
posDestrutivel [] [] = []
posDestrutivel (x:xs) (y:ys) = aux x y ++ posDestrutivel xs ys
  where
    aux :: [Peca] -> [Posicao] -> [Posicao]
    aux [] [] = []
    aux (x:xs) (y:ys) = if (x == Bloco Destrutivel) then y : aux xs ys else aux xs ys

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos das balas de 'Canhao' disparadas.
tickCanhoes :: Estado -> Estado
tickCanhoes = undefined

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos campos de 'Choque' disparados.
tickChoques :: Estado -> Estado
tickChoques = undefined
